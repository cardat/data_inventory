#+TITLE:Data Inventory 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----


* COMMENT todo list
> drv <- dbDriver("SQLite")
> tfile <- tempfile()
> con <- dbConnect(drv, dbname = "~/pitch.sqlite")
> dbListTables(con)
character(0)
> dbListTables(con)
character(0)
> con <- dbConnect(drv, dbname = "/home/ivan_hanigan/tools/web2py/applications/pitch/databases/storage.sqlite")
> dbListTables(con)
[1] "auth_cas"        "auth_event"      "auth_group"      "auth_membership"
[5] "auth_permission" "auth_user"       "post"            "sqlite_sequence"
> dbGetQuery(con , "select * from post")
  id  con user_id
1  1 asdf       1
2  2 asdf       2
3  3   hi       1
> dbGetQuery(con , "select * from post")
  id                 con user_id
1  1                asdf       1
2  2                asdf       2
3  3                  hi       1
4  4 this is a testing 1       2
> 

* COMMENT Init
** COMMENT torun-code
#+name:torun
#+begin_src sh :session *shell* :tangle no :exports none :eval no
#### name:torun####
# - include the server config: 
python ~/tools/web2py/web2py.py -a xpassword -i 0.0.0.0 -p 8181
#+end_src

** COMMENT README.md-code
#+name:README.md
#+begin_src R :session *R* :tangle ./README.md :exports none :eval no
#### Data Inventory

A web2py app to help manage research data

#+end_src
* Introduction
- There is a need for a data inventory tool to enable ecological data collections to be managed more efficiently
- The Ecological Metadata Language (EML) provides an excellent standardised schema for metadata, but the associated software Morpho does not have the flexibility or extensibility that would enable a data manager to use it to manage large and heterogeneous data collections
- This article describes an approach to use a relational database with web-based forms (using the web2py framework) and SQL helper functions (written in the R language) 
* The Ecological Metadata Language (EML)
The  Ecological Metadata Language (EML) schema is defined by the 'Knowledge Network for Biocomplexity' - KNB (https://knb.ecoinformatics.org/#tools/eml).  KNB is a subproject of  Ecoinformatics.org (http://ecoinformatics.org/).  Ecoinformatics.org is an open, voluntary collaboration of developers and researchers that aims to produce software, systems, publications, and services that are beneficial to the ecological and environmental sciences. 
** COMMENT snip
- We follow the LTER descriptions of best practice "~/references/LTER - Unknown - Introduction What is EML.pdf"
- We added some things like metadataProvider, but this is optional

** XML 
A minimal EML document is summarised below.  This is a schematic view that shows the structure of an EML XML document.  Only a few of the possible components are included.  


#+begin_src R :session *R* :tangle no :exports reports :eval no
    <eml>
        <dataset>
            <title>
            <creator> 
            <contact> 
            <project> 
                <title> 
                <personnel>
                    <role>
                <abstract>
                <funding>
                <studyAreaDescription>
                <designDescription>
                <relatedProject>
            <associatedParty>
            <publisher>
            <pubDate>
            <keywords>
            <abstract> 
            <intellectualRights>
            <methods> 
            <coverage>
            <dataTableerrors>
                <entityName>
                <entityDescription>                
                <physical>
                <attribute>
        <additionalMetadata>
            <additionalLinks>
  
#+end_src
** The parts of an EML document 
In EML, the term dataset is applied to a document which may contain
  general information such as the title, creator, and contacts,
  abstract and keywords as well as one or more data entities, such as
  datatables, that provide more specific research details.

The information is at the level of a particular data collection or
  study, however there is also a level above this at the "project"
  level where research studies can be grouped together.

In EML, the term dataset refers to one or more data
  entities.  However, there is no generally accepted practice on what to
  include in an EML-dataset document. Some people will choose to have
  a one-to-one correspondence between an EML document and a data
  entity and a single physical file. Others will document several data
  entities in one dataset document. 

 Below is a brief description of the way we interpret the components of an EML dataset

*** Datasets
Dataset is the top level of the EML.  The miminum necessary to
produce a valid EML document is <title>, <creator>, <contract>. But
one can't tell very much with just a title and a name.  Our aim is to
create an EML document that contains enough information about the data
and research to make funding agencies happy and give other ecologists
something to work with.

For more information about the general EML descriptions see:
https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-resource.html

For more detailed information about the EML-dataset module see: https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-dataset.html
*** Projects
The project module is optional, but in many cases highly desirable as
this provides an overall description of the larger-scale project or
research context with which that dataset is associated.  For example
it might be an entire Longterm Ecological Research Network (LTER)
site, or an individual project at an LTER site.

For more information about the EML-dataset module see:
https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html

*** Data Entity
As stated earlier, a dataset consists of one or more data entities,
and the most common data entity is a <dataTable>. A data table is
something that looks like a matrix with rows for observations and
columns for variables

In addition to datatables, people using database applications may also
  produce a <view> from a database management system or a
  <storedProcedure> that results in data output. People using GIS
  (geographical information system) applications generate both
  <spatialVector>, also referred to as boundary or shape files, and
  <spatialRaster>. A <spatialRaster> is a geo-referenced image usually
  produced by a camera on a satellite or other remote sensing
  device. The final kind of data entity is <otherEntity>. An
  <otherEntity> is a data entity that cannot be represented by any of
  the previously defined data entity structures. A non-geo-referenced
  photograph is an <otherEntity>, e.g., a photograph of two different
  types of butterflies.

For more information about types of EML-entities see: https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/#N10115

*** Attributes
An attribute or as it is sometime referred to, variable, in this
  context refers to the name of the column of a datatable

For more information about the EML dataTable type (especially its attributes) see:
https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-dataTable.html#attribute

** COMMENT snip 
This is where Morpho and other EML tools come into their own.  Our
  database solution might be useful as an initial stage of data
  documentation, to be further refined using specialised EML tools

* web2py 
** set up web2py 
- Web2py comes packaged up with everything it needs to run on a system (just needs python)
- run this using:
#+begin_src sh :session *shell* :tangle no :exports reports :eval no
#### Code:
    python ~/tools/web2py/web2py.py -a xpassword -i 0.0.0.0 -p 8181
#+end_src

** the web2py database example
- once the web server is running the example can be visited at this link:
- [[http://127.0.0.1:8181/examples/default/examples#database\_examples]]
- The default configuration of web2py uses the SQLite database engine
- Our implementation also utilises the PostgreSQL database which should be installed separately
* Design the database 
** Create a new database
- create a new postgres database using the following  code
#+name:create.db
#+begin_src sh :session *shell* :tangle no :exports reports :eval no
  sudo su
  su - postgres 
  createdb data_inventory
  psql -d data_inventory
  CREATE ROLE w2p_user LOGIN PASSWORD 'xpassword';
  grant all on schema public to w2p_user;
  \q
#+end_src
** Create a new web2py application
- this will create a directory in the applications folder of the web2py home directory
#+begin_src sh :session *shell* :tangle no :exports reports :eval no
  cd ~/tools/web2py 
  python ./web2py.py -S data_inventory
#+end_src

** relational model
- The structure we decided on was that there would be ONE project TO MANY datasets, ONE dataset to MANY datatables, and ONE datatable TO MANY attributes/variables
** defaults for models/db.py
- the database tables are set up in the models/db.py file that comes with default settings
- The first bit to change is the db reference from SQLite to postgres
- also note that "#if request.is\_local else []" will allow using as a server
- Then add new table definitions down the bottom.  
- Here we added projects, datasets, datatables and attributes.

# DISABLED DURING POSTGRES DEV 
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports none :eval no :padline no
  # -*- coding: utf-8 -*-
  
  #########################################################################
  ## This scaffolding model makes your app work on Google App Engine too
  ## File is released under public domain and you can use without limitations
  #########################################################################
  
  ## if SSL/HTTPS is properly configured and you want all HTTP requests to
  ## be redirected to HTTPS, uncomment the line below:
  # request.requires_https()
  
  if not request.env.web2py_runtime_gae:
      ## if NOT running on Google App Engine use SQLite or other DB
      ## db = DAL('sqlite://storage.sqlite',pool_size=1,check_reserved=['all'])
      db = DAL("postgres://w2p_user:xpassword@localhost:5432/data_inventory_ltern_dev_2")
  else:
      ## connect to Google BigTable (optional 'google:datastore://namespace')
      db = DAL('google:datastore')
      ## store sessions and tickets there
      session.connect(request, response, db=db)
      ## or store session in Memcache, Redis, etc.
      ## from gluon.contrib.memdb import MEMDB
      ## from google.appengine.api.memcache import Client
      ## session.connect(request, response, db = MEMDB(Client()))
  
  ## by default give a view/generic.extension to all actions from localhost
  ## none otherwise. a pattern can be 'controller/function.extension'
  response.generic_patterns = ['*'] # if request.is_local else []
  ## (optional) optimize handling of static files
  # response.optimize_css = 'concat,minify,inline'
  # response.optimize_js = 'concat,minify,inline'
  ## (optional) static assets folder versioning
  # response.static_version = '0.0.0'
  #########################################################################
  ## Here is sample code if you need for
  ## - email capabilities
  ## - authentication (registration, login, logout, ... )
  ## - authorization (role based authorization)
  ## - services (xml, csv, json, xmlrpc, jsonrpc, amf, rss)
  ## - old style crud actions
  ## (more options discussed in gluon/tools.py)
  #########################################################################
  
  from gluon.tools import Auth, Crud, Service, PluginManager, prettydate
  auth = Auth(db)
  crud, service, plugins = Crud(db), Service(), PluginManager()
  
  ## create all tables needed by auth if not custom tables
  auth.define_tables(username=False, signature=False)
  
  ## configure email
  mail = auth.settings.mailer
  mail.settings.server = 'logging' or 'smtp.gmail.com:587'
  mail.settings.sender = 'you@gmail.com'
  mail.settings.login = 'username:password'
  
  ## configure auth policy
  auth.settings.registration_requires_verification = False
  auth.settings.registration_requires_approval = False
  auth.settings.reset_password_requires_verification = True
  
  ## if you need to use OpenID, Facebook, MySpace, Twitter, Linkedin, etc.
  ## register with janrain.com, write your domain:api_key in private/janrain.key
  from gluon.contrib.login_methods.rpx_account import use_janrain
  use_janrain(auth, filename='private/janrain.key')
  
  #########################################################################
  ## Define your tables below (or better in another model file) for example
  ##
  ## >>> db.define_table('mytable',Field('myfield','string'))
  ##
  ## Fields can be 'string','text','password','integer','double','boolean'
  ##       'date','time','datetime','blob','upload', 'reference TABLENAME'
  ## There is an implicit 'id integer autoincrement' field
  ## Consult manual for more options, validators, etc.
  ##
  ## More API examples for controllers:
  ##
  ## >>> db.mytable.insert(myfield='value')
  ## >>> rows=db(db.mytable.myfield=='value').select(db.mytable.ALL)
  ## >>> for row in rows: print row.id, row.myfield
  #########################################################################
  
  ## after defining tables, uncomment below to enable auditing
  # auth.enable_record_versioning(db)
#+end_src
* Define our tables
The following sections show the definitions LTERN used to create the data inventory
** Project Information and Data Owners
- The EML Project module is used to place the dataset that is being documented into its larger research context.
- The KNB definition can be found at these links: [[./eml-2.1.1/docs/eml-2.1.1/eml-project.html][EML 2.1.1 definition]] or [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html][EML online]]
- The KNB says this is for 'Research context information for resources': The eml-project module describes the research context in which the dataset was created, including descriptions of over-all motivations and goals, funding, personnel, description of the study area etc. This is also the module to describe the design of the project: the scientific questions being asked, the architecture of the design, etc. 
- Morpho says: this metadata element is to recognise that data may be collected as part of a larger research program  (umbrella research project).  For example a large NSF grant may provide funds for several investigators to collect data at various locations.
- The new KNB metacat skin uses the title "Parent Project Information".
- Please also note the [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html#relatedProject]['relatedProject']] tag which LTERN is not currently using.  This 'is a recursive link to another project. This allows projects to be nested under one another for the case where one project spawns another.'

*** COMMENT project code
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### projects
  
  db.define_table(
      'project',
#+end_src
** eml/dataset/project/title
LTERN's suggested structure is either:
- the [Plot Network Name] (ie 'Victorian Alpine Plot Network') , or 
- a label that describes the [geographic coverage], [data type] and links to the [people] or [organisations] who own the data (ie Australian Tundra Experiment : Long Term Ecological Research Network (LTERN) - Victorian Alpine Plot Network).
- The KNB definition can be found at these links: [[./eml-2.1.1/docs/eml-2.1.1/eml-project.html#title][EML 2.1.1 definition]] or [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html#title][EML online]]

*** COMMENT project/title/code
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  Field('title', 'string',
  comment= XML(T('The EML Project module places the data into its larger research context. Suggested structure is: [Plot Network] OR [geographic coverage] [data type]. %s',
  A('More', _href=XML(URL('static','index.html',  anchor='sec-5-2', scheme=True, host=True)))))
  ),
#+end_src
** eml/dataset/project/personnel
In EML the Data Owner is able to be shown at various points on the xpath.  
LTERN uses the dataset/project/personnel/individualName or dataset/project/personnel/organizationName with  dataset/project/personnel/role == 'Data Owner' 
- The KNB definition can be found at these links: [[./eml-2.1.1/docs/eml-2.1.1/eml-project.html#personnel][EML 2.1.1 definition]] or [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html#personnel][EML online]]

*** COMMENT personnel-code
# cut XML(URL('static','eml-2.1.1/docs/eml-2.1.1/eml-project.html',  anchor='personnel', scheme=True, host=True)))

#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  Field('personnel','string', 
  comment= XML(T('Compulsory. A project must have at least one originator. At LTERN this is assumed to have role = data owner unless different role is specified. %s',
  A('More', _href=XML(URL('static','index.html',  anchor='sec-5-3', scheme=True, host=True)))))
  ),
#+end_src
** eml/dataset/project/abstract
The following information is used to create the LTERN Data Portal record for each Data Package:
Complete this section of the contextual metadata last. In that way you can collate the key facts from the rest of the metadata elements – the ‘quick touch’ approach.
We use the informative abstract method. The eml/dataset/project/abstract should be a descriptive of the umbrella project, not the dataset.
- Briefly outline the relevant project or study including the Plot Network name and describe the contents of the data package. 
- Include geographic location, the primary objectives of the study, what data was collected (species or phenomena), the year range the data was collected in, and collection frequency if applicable.
- Describe methodology techniques or approaches only to the degree necessary for comprehension – don’t go into any detail.
- Cite references and/or links to any publications that are related to the data package.
- Single paragraph. 200-250 words.
- Use active voice and past tense.
- Use short complete sentences.
- Express terms in both their abbreviated and spelled out form for search retrieval purposes.
- The KNB definition can be found at these links: [[./eml-2.1.1/docs/eml-2.1.1/eml-project.html#abstract][EML 2.1.1 definition]] or [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html#abstract][EML online]]
*** COMMENT abstract-code
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
      Field('abstract', 'text',
      comment= XML(T('Descriptive abstract that summarizes information about the umbrella project context of the specific project. %s',
      A('More', _href=XML(URL('static','index.html',  anchor='sec-5-4', scheme=True, host=True)))))
      ),
#+end_src
** eml/dataset/project/studyAreaDescription
- The KNB definition can be found at these links: [[./eml-2.1.1/docs/eml-2.1.1/eml-project.html#studyAreaDescription][EML 2.1.1 definition]] or [[https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-project.html#studyAreaDescription][EML online]]
*** COMMENT comment studydesc
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
      Field('studyAreaDescription','string', 
      comment= XML(T('This can include descriptions of the geographic, temporal, and taxonomic coverage of the research location. %s', 
      A('More', _href=XML(URL('static','index.html', anchor='sec-5-5', scheme=True, host=True)))))
      ) 
      )
  
      db.project.personnel.requires = IS_NOT_EMPTY()
#+end_src
** COMMENT dataset-setup-code
#+name:dataset-setup
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:dataset-setup####
  
  library(gdata)
  indir <- "~/Dropbox/projects/DataDocumentation/emldb"
  dir(indir)
  dat <-  read.xls(file.path(indir, "setup_emldb_crosswalks_master.xlsx"))
  str(dat)
  head(dat)
  table(dat$eml.table)
  
  # project
  
  tbl <- "project"
  psql <- paste(
    as.character(
      dat[which(dat$eml.table == tbl & dat$w2p_code !=""),"w2p_code"]
      ), sep = "", collapse = "\n"
    )
  psql <- gsub("&apos;", "'", psql)
  cat(psql)
  
  # dataset
  dat[which(dat$eml.table == tbl),1:3]
  tbl <- "dataset"
  psql <- paste(
    as.character(
      dat[which(dat$eml.table == tbl & dat$w2p_code !=""),"w2p_code"]
      ), sep = "", collapse = "\n"
    )
  psql <- gsub("&apos;", "'", psql)
  cat(psql)
#+end_src

** Dataset 
** COMMENT dataset

#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  #### ONE (project) TO MANY (dataset)
  
  db.define_table(
      'dataset',
      Field('project_id',db.project),
      Field('ltern_id','integer'),
      Field('title','string', comment='Suggested structure is: [umbrella project] [data type] [geographic coverage] [temporal coverage]'),
      Field('contact','string', comment = 'Compulsory'),
      Field('creator','string', comment='The name of the person, organization, or position who created the data'),
      Field('abstract','string'),
      Field('intellectualrights','string'),
      Field('pubdate','date'),
      Field('geographicdescription','string'),
      Field('boundingcoordinates','string'),
      Field('temporalcoverage','string'),
      Field('metadataprovider','string'),
      Field('tern_contract_type','string'),
      format = '%(title)s'
      )
  
  db.dataset.contact.requires = [IS_EMAIL()]

      
  # db.dataset.metadataprovider.requires = [IS_EMAIL(), IS_NOT_IN_DB(db, 'dataset.metadataprovider')]
     
#+end_src

** COMMENT old dataset
#+begin_src markdown :tangle no :exports reports :eval no :padline no
  
  #### ONE (project) TO MANY (dataset)
  
  db.define_table(
      'dataset',
      Field('project_id',db.project),
      Field('title','string'),
      Field('creator', 'string'),
      Field('contact','string'),
      Field('intellectualrights','string'),
      Field('pubdate','date'),
      Field('geographicdescription','string'),
      Field('temporalcoverage','string'),
      Field('metadataprovider','string'),
      format = '%(title)s'
      )

  db.dataset.metadataprovider.requires = [IS_EMAIL(), IS_NOT_IN_DB(db, 'dataset.metadataprovider')]

#+end_src
** COMMENT Data Entity
- https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/#N10115
- https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml-dataTable.html#numberOfRecords
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
    
  #### ONE (dataset) TO MANY (entity)
  
  db.define_table(
      'entity',
      Field('dataset_id',db.dataset),
      Field('entityname','string'),
      Field('entitydescription', 'text'),
      Field('numberOfRecords', 'integer')
      )
#+end_src
** COMMENT attribute
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### ONE (entity) TO MANY (attributes/variables)
  
  db.define_table(
      'attribute',
      Field('entity_id',db.entity),
      Field('name','string'),
      Field('definition', 'string')
      )
#+end_src
** COMMENT access 
An optional access tree at this location controls access to the entire metadata document. If this access element is omitted from the document, then the package submitter should be given full access to the package but all other users should be denied all access. 
https://knb.ecoinformatics.org/#external//emlparser/docs/eml-2.1.1/eml.html#access
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### accesss
  
  db.define_table(
      'access',
      Field('name'),
      Field('email'),
      Field('title', 'string'),
      Field('description', 'text'),
      format = '%(name)s'
      )
  #       format = '%(email)s'
  db.access.name.requires = IS_NOT_EMPTY()
  # db.access.email.requires = [IS_EMAIL(), IS_NOT_IN_DB(db, 'access.email')]
  
#+end_src
** COMMENT accessor
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### MANY (accessors) TO MANY (access members)
  
  db.define_table(
      'accessor',
      Field('access_id',db.access),
      Field('name'),
      Field('email'),
      )
  db.accessor.email.requires = [IS_EMAIL()]
  # , IS_NOT_IN_DB(db, 'accessor.email')]
         
#+end_src
** COMMENT access request
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### MANY (datasets) TO MANY (accessors)
  
  db.define_table(
      'accessrequest',
      Field('dataset_id',db.dataset),
      Field('access_id',db.access),
      Field('title', 'string'),
      format = '%(title)s %(access_id)s -> %(dataset_id)s'
      )

#+end_src
** COMMENT keywords
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
  
  #### MANY (keywords) TO one (dataset)
  
  db.define_table(
      'keyword',
      Field('dataset_id',db.dataset),
      Field('thesaurus', 'string', comment = 'source of authoritative definitions'),
      Field('keyword', 'string')
      )
    
#+end_src

** COMMENT deeds
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no
    
#### ONE (deed) TO one (dataset)
db.define_table(
    'deed',
    Field('dataset_id',db.dataset),
    Field('data_owner', 'string'),
    Field('special_permissions', 'string'),
    Field('licence_code', 'string')
    )
    
db.deed.data_owner.requires = IS_NOT_EMPTY()    
db.deed.licence_code.requires = IS_IN_SET(['CCBY', 'TERN-BYNC', 'adhoc'])    

#+end_src
** COMMENT checklists
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no

#### ONE (checklist) TO one (dataset)
db.define_table(
    'checklist',
    Field('dataset_id',db.dataset),
Field('checked_by','string'),
Field('check_date','date'),
Field('notes_comments','text'),
Field('data_package_title_check','boolean'),
Field('data_set_citation_check','boolean'),
Field('data_package_owner_check','boolean'),
Field('data_package_owner_check_individual_name','boolean'),
Field('data_package_owner_check_position_role','boolean'),
Field('data_package_owner_check_organization','boolean'),
Field('data_package_owner_check_address','boolean'),
Field('data_package_owner_check_phone','boolean'),
Field('data_package_owner_check_email_address','boolean'),
Field('associated_parties','boolean'),
Field('associated_parties_individual_name','boolean'),
Field('associated_parties_position','boolean'),
Field('associated_parties_organization','boolean'),
Field('associated_parties_physical_address','boolean'),
Field('associated_parties_phone','boolean'),
Field('associated_parties_email_address','boolean'),
Field('abstract','boolean'),
Field('keywords_and_subject_categories','boolean'),
Field('gcmd_science_keywords','boolean'),
Field('anzsrc_for_codes','boolean'),
Field('ltern_monitoring_themes','boolean'),
Field('keywords_free_text','boolean'),
Field('geographic_coverage','boolean'),
Field('geographic_description','boolean'),
Field('bounding_coordinates','boolean'),
Field('temporal_coverage','boolean'),
Field('contacts_individual_names','boolean'),
Field('contacts_positions','boolean'),
Field('contacts_organizations','boolean'),
Field('contacts_addresses','boolean'),
Field('contacts_phone','boolean'),
Field('contacts_email_addresses','boolean'),
Field('methods_and_sampling_information','boolean'),
Field('method_step_titles','boolean'),
Field('method_step_description','boolean'),
Field('instrumentation_details','boolean'),
Field('sampling_area_and_frequency','boolean'),
Field('sampling_description','boolean'),
Field('research_project_title','boolean'),
Field('research_project_funding_sources','boolean'),
Field('research_project_personnel_information','boolean'),
Field('research_project_individual_name','boolean'),
Field('research_project_position_role','boolean'),
Field('research_project_organization','boolean'),
Field('research_project_address','boolean'),
Field('research_project_phone','boolean'),
Field('research_project_email_address','boolean'),
Field('research_project_role','boolean'),
Field('additional_metadata','boolean'),

Field('access_control','boolean'),

Field('usage_rights','boolean'),
Field('special_conditions','boolean'),
Field('entity_metadata','boolean'),
Field('homepage_content','boolean'),
Field('eml_homepage_links','boolean'),
Field('can_the_plot_network_or_data_package_be_filtered_in_the_search_bar_of_the_portal','boolean'),
Field('draft_publication_checklist_passed','boolean'),
Field('metacat_publication_checklist_check_public_or_mediated_access','boolean'),
Field('metacat_publication_checklist_add_publication_date_to_data_inventory','boolean'),
Field('metacat_publication_checklist_passed','boolean'),
Field('reporting_checklist_licenced','boolean'),
Field('reporting_checklist_described_with_metadata_','boolean'),
Field('reporting_checklist_doi_minted','boolean'),
Field('reporting_checklist_metadata_feed_to_tddp_and_rda','boolean'),
Field('reporting_checklist_passed','boolean')
    )
    
db.checklist.checked_by.requires = IS_IN_SET(['Claire', 'Karl'])
db.checklist.check_date.requires = IS_NOT_EMPTY()
  
#+end_src

** COMMENT errors and addenda
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/models/db.py :exports reports :eval no :padline no

#### ONE (errors) TO one (dataset)
db.define_table(
    'error',
    Field('dataset_id',db.dataset),
Field('logged_by','string'),
Field('date_logged','date'),
Field('date_actioned','date'),
Field('error','text'),
Field('addenda','text')
    )
    
db.error.logged_by.requires = IS_NOT_EMPTY()
db.error.date_logged.requires = IS_NOT_EMPTY()    
#+end_src
* Design User Interface
** Defaults for controllers/default.py
- Following the example in the documentation 

#+name:controllers/default.py
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/default.py :exports none :eval no :padline no
  # -*- coding: utf-8 -*-
  # this file is released under public domain and you can use without limitations
  
  #########################################################################
  ## This is a sample controller
  ## - index is the default action of any application
  ## - user is required for authentication and authorization
  ## - download is for downloading files uploaded in the db (does streaming)
  ## - call exposes all registered services (none by default)
  #########################################################################
  
  
  def index():
      """
      example action using the internationalization operator T and flash
      rendered by views/default/index.html or views/generic.html
  
      if you need a simple wiki simply replace the two lines below with:
      return auth.wiki()
      """
      response.flash = T("Welcome to the data inventory!")
      return dict(message=T('This is a data inventory for ecological data collections'))
   
  
  def user():
      """
      exposes:
      http://..../[app]/default/user/login
      http://..../[app]/default/user/logout
      http://..../[app]/default/user/register
      http://..../[app]/default/user/profile
      http://..../[app]/default/user/retrieve_password
      http://..../[app]/default/user/change_password
      http://..../[app]/default/user/manage_users (requires membership in
      use @auth.requires_login()
          @auth.requires_membership('group name')
          @auth.requires_permission('read','table name',record_id)
      to decorate functions that need access control
      """
      return dict(form=auth())
  
  @cache.action()
  def download():
      """
      allows downloading of uploaded files
      http://..../[app]/default/download/[filename]
      """
      return response.download(request, db)
  
  
  def call():
      """
      exposes services. for example:
      http://..../[app]/default/call/jsonrpc
      decorate with @services.jsonrpc the functions to expose
      supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv
      """
      return service()
  
  
  @auth.requires_signature()
  def data():
      """
      http://..../[app]/default/data/tables
      http://..../[app]/default/data/create/[table]
      http://..../[app]/default/data/read/[table]/[id]
      http://..../[app]/default/data/update/[table]/[id]
      http://..../[app]/default/data/delete/[table]/[id]
      http://..../[app]/default/data/select/[table]
      http://..../[app]/default/data/search/[table]
      but URLs must be signed, i.e. linked with
        A('table',_href=URL('data/tables',user_signature=True))
      or with the signed load operator
        LOAD('default','data.load',args='tables',ajax=True,user_signature=True)
      """
      return dict(form=crud())

#+end_src
** Top Menu And Register Accessors
- From example 30 we get a simple user registration form. SQLFORM takes a table and returns the corresponding entry form with validators, etc. 
- The response.menu on top is just a variable used by the layout to make the navigation menu for all functions in this controller.
#+name:top menu and register a person
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/forms.py :exports reports :eval no
response.menu = [['Manage Projects', False, URL('manage_projects')],
                 ['Manage Datasets', False, URL('manage_datasets')],
                 ['Manage Access Groups', False, URL('manage_accessgroups')],
                 ['Register Access', False, URL('register_access')],
                 ['Access Dataset', False, URL('access_dataset')],
                 ['Documentation', False, XML(URL('static','index.html', scheme=True, host=True))]]
def register_access():
    # create an insert form from the table
    form = SQLFORM(db.access).process()

    # if form correct perform the insert
    if form.accepted:
        response.flash = 'new record inserted'

    # and get a list of all persons
    records = SQLTABLE(db().select(db.access.ALL),headers='fieldname:capitalize')

    return dict(form=form, records=records)

#+end_src

** Access a dataset
- Modified Example 32 from a sophisticated form that  checks the accessor  and the dataset are in the database and updates the corresponding record or inserts a new access. This version just adds another access record for each request.

#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/forms.py :exports reports :eval no :padline no
  def access_dataset():
      form = SQLFORM.factory(
          Field('access_id',requires=IS_IN_DB(db,db.access.id,'%(name)s')),
          Field('dataset_id',requires=IS_IN_DB(db,db.dataset.id,'%(title)s')),
          Field('title','string',requires=IS_NOT_EMPTY())).process()
      
      if form.accepted:
          # get previous access for same dataset
          access = db((db.accessrequest.access_id == form.vars.access_id)&
              (db.accessrequest.dataset_id==form.vars.dataset_id)).select().first()
  
          db.accessrequest.insert(access_id=form.vars.access_id,
                           dataset_id=form.vars.dataset_id,
                           title=form.vars.title)
  
          response.flash = 'dataset accessed!'
      elif form.errors:
          response.flash = 'invalid values in form!'
  
      
      # now get a list of all purchases
      accessing = (db.accessor.id==db.accessrequest.access_id)&(db.dataset.id==db.accessrequest.dataset_id)
      records = SQLTABLE(db(accessing).select(),headers='fieldname:capitalize')
      return dict(form=form, records=records)
  
  
#+end_src
** COMMENT DEPRECATED Access a dataset
- Example 32 is a rather sophisticated buy form. It checks that the buyer and the product are in the database and updates the corresponding record or inserts a new purchase. It also does a JOIN to list all purchases. 
# controllers/forms.py
#+begin_src R :session *R* :tangle no :exports reports :eval no :padline no
  def access_dataset():
      form = SQLFORM.factory(
          Field('accessor_id',requires=IS_IN_DB(db,db.accessor.id,'%(email)s')),
          Field('dataset_id',requires=IS_IN_DB(db,db.dataset.id,'%(title)s')),
          Field('title','string',requires=IS_NOT_EMPTY())).process()
      if form.accepted:
          # get previous access for same dataset
          access = db((db.access.accessor_id == form.vars.accessor_id)&
              (db.access.dataset_id==form.vars.dataset_id)).select().first()
  
          if access:
              # if list contains a record, update that record
              access.update_record(
                  title = form.vars.title)
          else:
              # self insert a new record in table
              db.access.insert(accessor_id=form.vars.accessor_id,
                               dataset_id=form.vars.dataset_id,
                               title=form.vars.title)
          response.flash = 'dataset accessed!'
      elif form.errors:
          response.flash = 'invalid values in form!'
  
      
      # now get a list of all purchases
      accessing = (db.accessor.id==db.access.accessor_id)&(db.dataset.id==db.access.dataset_id)
      records = SQLTABLE(db(accessing).select(),headers='fieldname:capitalize')
      return dict(form=form, records=records)
  
#+end_src
** Register access view
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/views/forms/access_dataset.html :exports reports :eval no :padline no
  
  {{extend 'layout.html'}}
  <h1>Access form</h1>
    {{=form}}
    [ {{=A('delete accesses',_href=URL('delete_accessed'))}} ]
    <h2>Current access (SQL JOIN!)</h2>
  <p>{{=records}}</p>
  
  
#+end_src

** Main form ties it all together (manage projects)
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/forms.py :exports reports :eval no :padline no
  
  def manage_projects():
      grid = SQLFORM.smartgrid(db.project,linked_tables=['dataset', 'entity','deed', 'attribute','accessrequest', 
                                                        'checklist', 'error'],
                               fields = [db.project.title,db.project.id,
                                         db.dataset.title, db.dataset.ltern_id,db.dataset.tern_contract_type,
                                         db.entity.entityname,
                                         db.attribute.name, db.attribute.definition,
                                         db.accessrequest.access_id, 
                                         db.accessrequest.dataset_id,
                                         db.accessrequest.title, 
                                         db.error.logged_by, db.error.date_logged,
                                         db.checklist.checked_by, db.checklist.check_date, 
                                         db.checklist.draft_publication_checklist_passed, db.checklist.reporting_checklist_passed, 
                                         db.deed.data_owner],
                                         orderby = dict(project=db.project.id, dataset=db.dataset.title),
                               user_signature=True,maxtextlength =200)
      return dict(grid=grid)
#+end_src  
** COMMENT deprecated manageproj-code
#+name:deprecated manageproj
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:deprecated manageproj####

  def manage_projects():
      grid = SQLFORM.smartgrid(db.project,linked_tables=['dataset', 'entity', 'attribute','accessrequest', 'keyword'],
                               fields = [db.project.title,
                                         db.dataset.title, db.dataset.creator,
                                         db.entity.entityname,
                                         db.attribute.name, db.attribute.definition,
                                         db.accessrequest.accessor_id, db.accessrequest.dataset_id,
                                         db.accessrequest.title, 
                                         db.keyword.thesaurus, db.keyword.keyword],
                               user_signature=True,maxtextlength =200)
      return dict(grid=grid)
  
#+end_src

** Form to manage all datasets
#+name:manage datasets
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/forms.py :exports reports :eval no :padline no
  
  def manage_datasets():
      grid = SQLFORM.smartgrid(db.dataset,linked_tables=['project', 'entity','deed', 'attribute','accessrequest', 
                                                         'checklist',  'error'],
                               fields = [db.dataset.project_id,
                                         db.dataset.title, db.dataset.ltern_id,db.dataset.tern_contract_type,
                                         db.entity.entityname,
                                         db.attribute.name, db.attribute.definition,
                                         db.accessrequest.access_id, db.accessrequest.dataset_id,
                                         db.accessrequest.title, 
                                         db.error.logged_by, db.error.date_logged,
                                         db.checklist.checked_by, db.checklist.check_date, 
                                         db.checklist.draft_publication_checklist_passed, db.checklist.reporting_checklist_passed, 
                                         db.deed.data_owner],
                                         orderby = dict(dataset=[db.dataset.project_id,db.dataset.title]),
                               user_signature=True,maxtextlength =200)
      return dict(grid=grid)
  
#+end_src

** Form to manage all access groups
*** COMMENT manage access groups
#+begin_src R :session *R* :tangle ~/tools/web2py/applications/data_inventory/controllers/forms.py :exports reports :eval no :padline no
  
  def manage_accessgroups():
      grid = SQLFORM.smartgrid(db.access,linked_tables=['accessor'],
                               fields = [
                                         db.access.name,
                                         db.access.email,
                                         db.accessor.name, db.accessor.email],
                                         orderby = dict(access=[db.access.name]),
                               user_signature=True,maxtextlength =200)

      return dict(grid=grid)
      # db.accessor.email.requires = [IS_IN_DB(db,db.accessor.id,'%(email)s')]  
#+end_src

*** COMMENT summarise-access-code
#+name:summarise-access
#+begin_src R :session *R* :tangle no :exports none :eval no
#### name:summarise-access####
select foo.*, t3.*
from (
SELECT t1.*, t2.title
  FROM accessrequest t1
  join dataset t2
  on t1.dataset_id = t2.id
  ) foo
  join accessor t3
  on foo.accessor_id = t3.id

#+end_src

** finesse the interface
- the following makes a home page
- also go to static/css/web2py.css and change line 33/34 text width to about 800px
#+begin_src markdown :tangle ~/tools/web2py/applications/data_inventory/views/default/index.html :exports reports :eval no :padline
  {{left_sidebar_enabled,right_sidebar_enabled=False,('message' in globals())}}
  {{extend 'layout.html'}}
  
  {{if 'message' in globals():}}
  <h3>{{=message}}</h3>
  
  <h4>{{=T('Instructions')}}</h4>
  <ol>
    <li>{{=T('You are using the data inventory')}}</li>
    <li>{{=XML(T('The main tool for managing research projects (umbrella grouping of packages) is at %s',
             A('%(application)s/forms/manage_projects/'%request,
             _href=URL('forms','manage_projects'))))}}</li>
    <li>{{=XML(T('The main tool for managing datasets (packages) is at %s',
             A('%(application)s/forms/manage_datasets/'%request,
             _href=URL('forms','manage_datasets'))))}}</li>
    <li>{{=XML(T('The technical documentation for this application is at %s',
             A('this link',
             _href=URL('static','index.html'))))}}</li>  
  </ol>
  {{elif 'content' in globals():}}
  {{=content}}
  {{else:}}
  {{=BEAUTIFY(response._vars)}}
  {{pass}}
  
  {{block right_sidebar}}
  {{=A(T("Administrative Interface"), _href=URL('admin','default','index'), _class='btn',
       _style='margin-top: 1em;')}}
  {{end}}
  
#+end_src

* COMMENT migrate DDI R Code
** COMMENT load data-code
#+name:load data
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:load data####
  library(swishdbtools)
  ch <- connect2postgres2("data_inventory2")
  
  pgListTables(ch, "public")
  
  indir <- "~/Dropbox/projects/0.3 Catalogue/backups/csvs/2014-04-15"
  dir(indir)
  dat <- read.csv(file.path(indir, "STDYDSCR_edit.csv"))
  str(dat)
  dbWriteTable(ch, "stdydscr", dat)
  
  names(table(dat$IDNO))
  names(table(dat$AUTHENTY))
  names(table(dat$DISTRBTR))
  
  
  stdy <- dat[grep("ECOR", dat$IDNO),]
  t(stdy[,1:25])
  matrix(names(stdy))
  
  
  
  dat <- read.csv(file.path(indir, "FILEDSCR.csv"))
  str(dat)
  names(table(dat$IDNO))
  dat[grep("mesic", dat$FILENAME),]
  
  file <- dat[grep("ECOR", dat$IDNO),]
  file
  
#+end_src

* COMMENT DEPRECATED old crap
** COMMENT load old access data
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:asdf####
  library(stringr)
  library(swishdbtools)
  library(sqldf)
  ch <- connect2postgres2("data_inventory2")
  pgListTables(ch, "public")
  
  dat2 <- dbGetQuery(ch, "select * from project")
  str(dat2)
  head(dat2)
  names(dat2)
  
  
  fpath1 <- dir("/home/ivan_hanigan/Dropbox/data/ltern_data_inventory-backups", pattern = "csv", full.names=T)
  fpath1
  flist <-  as.data.frame(matrix(    unlist(str_split(fpath1,"-"))                       , ncol =9, byrow=T))
  flist[,3:6]
  head(flist)
  flist$date <- as.Date(
    paste(flist$V4,"-", flist$V5,"-", flist$V6,sep = "")
    )
  infile <- flist[which(flist$date == max(flist$date)),]
  infiles <- fpath1[which(flist$date == max(flist$date))]
  infiles
  
  
  # for
  i <- 3
  fpath <-infiles[i]
  fpath
  
  dat <- read.csv(fpath, stringsAsFactors = F)
  str(dat)
  dat
  
  names(dat)
  
  datx <- as.data.frame(table(dat$pn_code_broad_group))
  datx
  for(i in 2:nrow(datx)){
  #  i <- 2
  t(datx[i,1]  )
  sql <- sprintf(
    "INSERT INTO project(
              title)
      VALUES ('%s')
    ", datx$Var1[i])
  cat(sql)
  dbSendQuery(ch, sql)
  }
  
  
  infiles
  i <- 2
  fpath <-infiles[i]
  fpath
  
  dat <- read.csv(fpath, stringsAsFactors = F)
  str(dat)
  #dat
  
  names(dat)
  
  
  for(i in 2:nrow(dat)){
    i <- 1
  pid <- dbGetQuery(ch,
                    sprintf(
                      "select id from project where title = %s",
                      )
  
    
  sql <- sprintf(
     "INSERT INTO dataset(
              id, project_id, title, creator, contact, metadataprovider, intellectualrights, 
              pubdate, temporalcoverage, boundingcoordinates, geographicdescription, 
              abstract)
      VALUES (?, ?, ?, ?, ?, ?, ?, 
              ?, ?, ?, ?, 
              ?)"
  , dat$refid[i], dat$data_package_title[i], dat$notes[i], dat$contact_name[i])
  cat(sql)
  dbSendQuery(ch, sql)
  }
  
  
  for(i in 2:nrow(dat)){
  #  i <- 1
  sql <- sprintf(
  "INSERT INTO dataset(
              id, project_id, title, creator, contact, metadataprovider, intellectualrights, 
              pubdate, temporalcoverage, boundingcoordinates, geographicdescription, 
              abstract)
      VALUES (?, ?, ?, ?, ?, ?, ?, 
              ?, ?, ?, ?, 
              ?);
    ", dat$refid[i], dat$data_package_title[i], dat$notes[i], dat$contact_name[i])
  cat(sql)
  dbSendQuery(ch, sql)
  }
  
#+end_src
** COMMENT first attempt at data inventory tables

*** COMMENT models/db.py-code
- 
- The first bit to change is the db reference from SQLite to postgres
#+begin_src markdown :tangle no :exports reports :eval no :padline no
  # -*- coding: utf-8 -*-
  
  #########################################################################
  ## This scaffolding model makes your app work on Google App Engine too
  ## File is released under public domain and you can use without limitations
  #########################################################################
  
  ## if SSL/HTTPS is properly configured and you want all HTTP requests to
  ## be redirected to HTTPS, uncomment the line below:
  # request.requires_https()
  
  if not request.env.web2py_runtime_gae:
      ## if NOT running on Google App Engine use SQLite or other DB
      # db = DAL('sqlite://storage.sqlite',pool_size=1,check_reserved=['all'])
      db = DAL("postgres://w2p_user:xpassword@localhost:5432/data_inventory")
  else:
      ## connect to Google BigTable (optional 'google:datastore://namespace')
      db = DAL('google:datastore')
      ## store sessions and tickets there
      session.connect(request, response, db=db)
      ## or store session in Memcache, Redis, etc.
      ## from gluon.contrib.memdb import MEMDB
      ## from google.appengine.api.memcache import Client
      ## session.connect(request, response, db = MEMDB(Client()))
  
  ## by default give a view/generic.extension to all actions from localhost
  ## none otherwise. a pattern can be 'controller/function.extension'
  response.generic_patterns = ['*'] #if request.is_local else []
  ## (optional) optimize handling of static files
  # response.optimize_css = 'concat,minify,inline'
  # response.optimize_js = 'concat,minify,inline'
  ## (optional) static assets folder versioning
  # response.static_version = '0.0.0'
  #########################################################################
  ## Here is sample code if you need for
  ## - email capabilities
  ## - authentication (registration, login, logout, ... )
  ## - authorization (role based authorization)
  ## - services (xml, csv, json, xmlrpc, jsonrpc, amf, rss)
  ## - old style crud actions
  ## (more options discussed in gluon/tools.py)
  #########################################################################
  
  from gluon.tools import Auth, Crud, Service, PluginManager, prettydate
  auth = Auth(db)
  crud, service, plugins = Crud(db), Service(), PluginManager()
  
  ## create all tables needed by auth if not custom tables
  auth.define_tables(username=False, signature=False)
  
  ## configure email
  mail = auth.settings.mailer
  mail.settings.server = 'logging' or 'smtp.gmail.com:587'
  mail.settings.sender = 'you@gmail.com'
  mail.settings.login = 'username:password'
  
  ## configure auth policy
  auth.settings.registration_requires_verification = False
  auth.settings.registration_requires_approval = False
  auth.settings.reset_password_requires_verification = True
  
  ## if you need to use OpenID, Facebook, MySpace, Twitter, Linkedin, etc.
  ## register with janrain.com, write your domain:api_key in private/janrain.key
  from gluon.contrib.login_methods.rpx_account import use_janrain
  use_janrain(auth, filename='private/janrain.key')
  
  #########################################################################
  ## Define your tables below (or better in another model file) for example
  ##
  ## >>> db.define_table('mytable',Field('myfield','string'))
  ##
  ## Fields can be 'string','text','password','integer','double','boolean'
  ##       'date','time','datetime','blob','upload', 'reference TABLENAME'
  ## There is an implicit 'id integer autoincrement' field
  ## Consult manual for more options, validators, etc.
  ##
  ## More API examples for controllers:
  ##
  ## >>> db.mytable.insert(myfield='value')
  ## >>> rows=db(db.mytable.myfield=='value').select(db.mytable.ALL)
  ## >>> for row in rows: print row.id, row.myfield
  #########################################################################
  
  ## after defining tables, uncomment below to enable auditing
  # auth.enable_record_versioning(db)
  
  # db.define_table('dataset',
  #   Field('pn_code', 'string'),
  #   Field('plot_network_study_name', 'string'),
  #   Field('dataset', 'string'),
  #   Field('tern_type', 'string'),
  #   Field('ltern_publ_url','string'),
  #   Field('abstract', 'text')
  # )
  
  db.define_table('data_inventory',
      Field('id2', 'integer'),
      Field('plot_network_study_name','text'),
      Field('pn_group','text'),
      Field('pn_code','text'),
      Field('data_custodian','text'),
      Field('plot_network','text'),
      Field('pi','text'),
      Field('data_custodian_pl_pi','text'),
      Field('data_custodian_organisation','text'),
      Field('data_type','text'),
      Field('notes_issues','text'),
      Field('start_date','integer'),
      Field('end_date','integer'),
      Field('current_status','text'),
      Field('sites_plots','integer'),
      Field('collection_timeframes','text'),
      Field('ecosystem_mvg_numbers','integer'),
      Field('mvg_names','text'),
      Field('tern_type','text'),
      Field('data_interview_status','text'),
      Field('data_interview_date','date'),
      Field('deed_status','text'),
      Field('deed_status_date','date'),
      Field('licence_code','text'),
      Field('access_restrictions','text'),
      Field('estimate_timeframe_data_ready_by_plot','date'),
      Field('date_data_expected_by_ltern','date'),
      Field('date_data_received_by_ltern','date'),
      Field('stored_at','text'),
      Field('eda_status','text'),
      Field('eda_status_date','date'),
      Field('metadata_status','text'),
      Field('metadata_status_date','date'),
      Field('publishing','text'),
      Field('date_published','date'),
      Field('estimated_effort','text'),
      Field('allocated_to','text'),
      Field('depends_on','text'),
      Field('todo_or_done','text'))
  
  #### projects and datasets
  db.define_table(
      'project',
      Field('title', 'string'),
      Field('abstract', 'text')
      )
  
  #### ONE (project) TO MANY (datasets)
  
  db.define_table(
      'dataset',
      Field('project_id',db.project),
      Field('title','string'),
      Field('creator', 'string')
      )
  
  #### ONE (dataset) TO MANY (attributes/variables)
  
  db.define_table(
      'attribute',
      Field('dataset_id',db.dataset),
      Field('name','string'),
      Field('definition', 'string')
      )
  
#+end_src
*** COMMENT controllers/default.py-code
#+name:controllers/default.py
#+begin_src R :session *R* :tangle no :exports none :eval no :padline no
  # -*- coding: utf-8 -*-
  # this file is released under public domain and you can use without limitations
  
  #########################################################################
  ## This is a sample controller
  ## - index is the default action of any application
  ## - user is required for authentication and authorization
  ## - download is for downloading files uploaded in the db (does streaming)
  ## - call exposes all registered services (none by default)
  #########################################################################
  
  
  def index():
      """
      example action using the internationalization operator T and flash
      rendered by views/default/index.html or views/generic.html
  
      if you need a simple wiki simply replace the two lines below with:
      return auth.wiki()
      """
      response.flash = T("Welcome to web2py!")
      return dict(message=T('Hello World'))
   
  
  def user():
      """
      exposes:
      http://..../[app]/default/user/login
      http://..../[app]/default/user/logout
      http://..../[app]/default/user/register
      http://..../[app]/default/user/profile
      http://..../[app]/default/user/retrieve_password
      http://..../[app]/default/user/change_password
      http://..../[app]/default/user/manage_users (requires membership in
      use @auth.requires_login()
          @auth.requires_membership('group name')
          @auth.requires_permission('read','table name',record_id)
      to decorate functions that need access control
      """
      return dict(form=auth())
  
  @cache.action()
  def download():
      """
      allows downloading of uploaded files
      http://..../[app]/default/download/[filename]
      """
      return response.download(request, db)
  
  
  def call():
      """
      exposes services. for example:
      http://..../[app]/default/call/jsonrpc
      decorate with @services.jsonrpc the functions to expose
      supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv
      """
      return service()
  
  
  @auth.requires_signature()
  def data():
      """
      http://..../[app]/default/data/tables
      http://..../[app]/default/data/create/[table]
      http://..../[app]/default/data/read/[table]/[id]
      http://..../[app]/default/data/update/[table]/[id]
      http://..../[app]/default/data/delete/[table]/[id]
      http://..../[app]/default/data/select/[table]
      http://..../[app]/default/data/search/[table]
      but URLs must be signed, i.e. linked with
        A('table',_href=URL('data/tables',user_signature=True))
      or with the signed load operator
        LOAD('default','data.load',args='tables',ajax=True,user_signature=True)
      """
      return dict(form=crud())
  
  def entry_datasets():
      """returns a form where the can entry a post"""
      form = crud.create(db.data_inventory)
      return dict(form=form)
  
  #def search_dogs():
  #    form, records = crud.search(db.datainventory)
  #    return dict(form=form, records=records)
  
  def search_dogs():
      return dict(form=SQLFORM.grid(db.data_inventory, user_signature=True, maxtextlength =200,
                                    fields = [db.data_inventory.id, db.data_inventory.plot_network_study_name, db.data_inventory.pn_group, db.data_inventory.data_type, db.data_inventory.eda_status_date]))
  
  
  def search_datasets():
      return dict(form=SQLFORM.grid(db.dataset.id==db.data_inventory.id2, user_signature=True, maxtextlength =200,
                                    fields = [db.dataset.id, db.dataset.plot_network_study_name, db.dataset.pn_code, db.dataset.dataset, db.dataset.tern_type, db.data_inventory.notes_issues]))
  
  
  
  def manage_projects():
      grid = SQLFORM.smartgrid(db.project,linked_tables=['dataset', 'attribute'],
                               fields = [db.project.title,
                                         db.dataset.title, db.dataset.creator,
                                         db.attribute.name, db.attribute.definition],
                               user_signature=True)
      return dict(grid=grid)
  
#+end_src
